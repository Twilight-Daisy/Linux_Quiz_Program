/*모든 라이브러리가 쓰여 있는 게 아닙니다.
쓰이지 않는 라이버리가 있어요.
*/
#include <algorithm>
#include <bits/stdc++.h>
#include <cctype>
#include <fcntl.h>
#include <iostream>
#include <stack>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <vector>
using namespace std;

// How does it work?
// 1) Recieve form a user a command.
// 2) Split the string command into separate words and puts them into arrays.
// 3)When the command is solved programm starts matching.

class commands /*commands 클레스가 입력된 명령어는 맞게 입력되었는지 확인하는 메소드를   지니고 있다. 각각 명령어를 위해서 메소드를 만들어 놓았어요.*/
{
public:
    void pwd_cmd(vector<string> inp_cm);
    void ls_cmd(vector<string> &vect_cmd, vector<string> &vect_path);
    void cp_cmd(vector<string> &vect_cmd, vector<string> &vect_path, vector<string> &vect_name);
    void mv_cmd(); //아직 코드 작성을 안 했어요
    void rm_cmd();
    void check();
    commands(vector<string> &vect_cmd, vector<string> &vect_path, vector<string> &vect_name); //constructor을 통해서 클래스 안에 외부의 배열을 집어넣어요.

private:
    vector<string> vect_cmd;
    vector<string> vect_path;
    vector<string> vect_name;
    vector<string> pwd{"pwd"}; // 이 벼열들은 사용자가 입력한 명령어를 검사할 때 쓰이어요.
                               // 첫 번째 요소는 명렁어의 이름이어야 해요.
    vector<string> ls{"ls", "-a", "-l", "-F", "-r", "-t", "-S"};
    vector<string> cp{"cp", "-a", "-b", "-f", "-i", "-r", "-u"};
    vector<string> mv{"mv", "-b", "-f", "-i", "-v", "-u"};
    vector<string> rm{"rm", "-d", "-i", "-f", "-r", "-v"};
};
// this is a class constructor. 외부 배열을 class에 넣어요.
commands::commands(vector<string> &vect_cmd, vector<string> &vect_path, vector<string> &vect_name)
{
    this->vect_cmd = vect_cmd;   //이 배열 안에 명령어와 옵션들이 있어요.
    this->vect_path = vect_path; //"mv ./dir1/txt.txt /dir/dir/dir"와 처럼  경로가 있는 경우에 입력된 경로가 이 배열로 들어가요.
    this->vect_name = vect_name; // "touch txt.txt"와 처럼 명령어와 같이 입력된 파일이나 디렉토리의 이름을 보관하는 배열이에요.
}

void commands::check() //이 메소드가 두 배열의 첫번째 값을 비교해서 결과에 따라 확인하는 과정이 자동으로 시작해요. 지금 pwd 과 ls밖에 없어서 메소드 완성되지 않은 상태예요.
{
    if (vect_cmd.front() == pwd.front())
    {
        pwd_cmd(vect_cmd);
    }
    else if (vect_cmd.front() == ls.front())
    {
        ls_cmd(vect_cmd, vect_path);
    }
}
// 만약 둘 배열의 [0]인 값이 "pwd"라면 아래의 메소드로 전송돼요.

void commands::pwd_cmd(vector<string> inp_cmd)
{
    if (pwd == inp_cmd) //pwd 같은 경우에 명령어밖에 없어요. 그래서 입력된 명령어가 하나예요.
    {
        cout << "Right\n";
    }
    else // 명령어가 맞지만 실수로 옵션도 입력되어 있어요. "pwd - f"
        cout << "Command '" << inp_cmd.front() << "'"
             << "not found, did you mean: " << pwd.front() << "\n";
}

void commands::ls_cmd(vector<string> &vect_cmd, vector<string> &vect_path)
{
    vector<string> cmd_line; //cmd란 배열에서 요소를 빼는 과정이에요.
    for (int i = 0; i < vect_cmd.size(); i++)
    {
        for (int j = 0; j < ls.size(); j++)
        {
            if (ls[j] == vect_cmd[i])
            {
                cmd_line.push_back(vect_cmd[i]);
                vect_cmd.erase(vect_cmd.begin() + i);
                i--;
                break;
            }
        }
    }

    if (vect_cmd.size() == 0)
    {
        cout << "Right!\n";
        for (int i = 0; i < cmd_line.size(); i++)
        {
            cout << cmd_line[i] << " ";
        }

        if (vect_path.size() != 0)
        {
            for (int j = 0; j < vect_path.size(); j++)
            {
                cout << vect_path[j];
            }
        }
        cout << "\n";
    }

    else if (vect_cmd.size() != 0) // 남아 있는 것은 틀리게 입력된 옵션이 남아 있어요.
    {
        cout << cmd_line.front() << ": invalid option ";
        for (int i = 0; i < vect_cmd.size(); i++)
        {
            cout << "'" << vect_cmd[i] << "'";
        }
        cout << "\n";
    }
}

void commands::cp_cmd(vector<string> &vect_cmd, vector<string> &vect_path, vector<string> &vect_name) //Not finished
{
}

void commands::mv_cmd() //not finished
{
}

void commands::rm_cmd() //not finished
{
}

// This method is used to split user's command into separate words and put them inside vectors.
void command_build(string inp_cmd, vector<string> &vect_cmd, vector<string> &vect_name, vector<string> &vect_path)
{
    string srch;
    string wrd;
    istringstream split_snt(inp_cmd);
    while (split_snt >> wrd)
    {
        if (wrd.at(0) == '.' || wrd.at(0) == '/')
        {
            vect_path.push_back(wrd); //Stores pathes 경로가 저장돼요
        }
        else
            vect_cmd.push_back(wrd); //Stores commands and options 명령어와 옵션 저장돼요
    }

    for (int i = 0; i < vect_cmd.size(); i++) //이제 이름을 찾아야 하는 과정이 사작해요.
    {
        if (vect_cmd[i] == vect_cmd.front() || (vect_cmd[i].at(0) == '-'))
        {
            continue;
        }
        else
        {
            srch = vect_cmd[i];
            vect_name.push_back(srch); //Stores directories and files names
            vector<string>::iterator result = find(vect_cmd.begin(), vect_cmd.end(), srch);
            vect_cmd.erase(result);
        }
        i--;
    }
}

int main()
{
    //Problems: Code is not finished. It doesn no how to act if a commnad is written wrongly and there is no any matches.

    string inp_cmd;           // 입력된 명령어가 저장되는 변수.
    vector<string> vect_cmd;  // 이 배열 안에 명령어가 저장된다 예를 들어 "ls -a"
    vector<string> vect_name; // 파일이나 디렉토리의 이름인  경우 저장되는 장소 "mkdir project"
    vector<string> vect_path; // 만약에 명령어와 같이 경로가 입력되면 바로 여기로 보내게 된다. "./bin/bahs/user"
    cout << "!! NOW PWD and LS commands are available!!! Enter the command: " << endl;
    getline(cin, inp_cmd);                                  //Input a command from the user.
    command_build(inp_cmd, vect_cmd, vect_name, vect_path); //Recived command should be splited into 3 "command and options" "path of file or directory" and "files and directories names"
    commands call(vect_cmd, vect_path, vect_name);          // When  the command from user is done Programm put them into the cmmands class. All operations will be done in that class.
    call.check();                                           // thi method findes matches between user's command and command which are stored inside the Programm.

    return 0;
}

// This is doesn't work or still not finished
// 실행 실패 , 완성이 되지 않은 코드예요.

/* File creation 1

#include <fcntl.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
#define PERMS 0644
int main()
{
    char name[30];
    printf("Enter name: ");
    fgets(name, sizeof(name), stdin);

    int fd = open("foo.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (fd < 0)
    {
        perror("r1");
        exit(1);
    }
    int sz = write(fd, name, strlen(name));
    lseek(sz, 8, SEEK_CUR);
    sz = write(fd, "hello", strlen("Hello"));
    close(fd);
    return 0;
}
*/

/* Basic menu
#include <fcntl.h>
#include <iostream>
#include <stack>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

using namespace std;
#define PERMS 0644

class menulist
{
public:
    void calls();
    void messages();
};

void menulist::calls()
{
    cout << "Games" << endl;
};

void menulist::messages()
{
    cout << "Test" << endl;
};

int main()
{

    int i;
    menulist obj;
    while (i != 0)
    {
        cin >> i;
        switch (i)
        {
        case 1:
            obj.messages();
            break;
        case 2:
            obj.calls();
            break;
        }
    }
return 0;
}
*/

/* File Creation 2
#include <fcntl.h>
#include <iostream>
#include <stack>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
#define PERMS 0644

int main()
{
    int fd = 0;
    const char *pathname = "./answer.txt";
    const char *msg = "Hello World!\n";
    ssize_t wsize = 0;
    fd = creat(pathname, PERMS);
    fd = open(pathname, O_CREAT | O_TRUNC | O_RDWR, PERMS);
    if (fd == -1)
    {
        perror("open() error!");
        exit(-1);
    }
    wsize = write(fd, (char *)msg, strlen(msg));
    if (wsize == -1)
    {
        perror("write() error!");
        exit(-2);
    }
    close(fd);
    return 0;
}
*/

/* Structure
#include <algorithm>
#include <bits/stdc++.h>
#include <cctype>
#include <fcntl.h>
#include <iostream>
#include <stack>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>
using namespace std;
enum ExamType
{
    EXAM_PRACTICE,
    EXAM_EXERCISE,
};

class Exam
{
public:
    Exam();
    Exam(ExamType type, string description, string hint, string command, string answer);
    ExamType getType();
    string getDes();
    string getHint();
    string getCommand();
    string getAnswer();

    void setType(ExamType type);
    void setDes(string des);
    void setHint(string hint);
    void setCommand(string command);
    void setAnswer(string answer);

private:
    ExamType type;
    string description;
    string hint;
    string command;
    string answer;
};

Exam::Exam()
{
    this->answer = "";
    this->command = "";
    this->description = "";
}

Exam::Exam(ExamType type, string description, string hint, string command, string answer)
{
    this->type = type;
    this->description = description;
    this->command = command;
    this->hint = hint;
    this->answer = answer;
}

void Exam::setType(ExamType type)
{
    this->type = type;
}
void Exam::setDes(string des)
{
    this->description = des;
}
void Exam::setHint(string hint)
{
    this->hint = hint;
}
void Exam::setCommand(string command)
{
    this->command = command;
}
void Exam::setAnswer(string answer)
{
    this->answer = answer;
}

ExamType Exam::getType()
{
    return type;
}
string Exam::getDes()
{
    return description;
}
string Exam::getHint()
{
    return hint;
}
string Exam::getCommand()
{
    return command;
}
string Exam::getAnswer()
{
    return answer;
}

class test
{
private:
    int a;

public:
    test();
    test(int v);
    void disp();
};
test::test()
{
    a = 0;
}
test::test(int v)
{
    this->a = v;
};
void test::disp()
{
    cout << a << endl;
};
*/
